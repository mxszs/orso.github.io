<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>or_so</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-03T11:03:18.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>or_so</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>G6</title>
    <link href="http://yoursite.com/2018/11/03/G6/"/>
    <id>http://yoursite.com/2018/11/03/G6/</id>
    <published>2018-11-03T03:27:30.000Z</published>
    <updated>2018-11-03T11:03:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="G6"><a href="#G6" class="headerlink" title="G6"></a>G6</h1><blockquote><p>G6 是一个简单、易用、完备的图可视化引擎，它在高定制能力的基础上，提供了一系列设计优雅、便于使用的图可视化解决方案。能帮助开发者搭建属于自己的图 图分析 应用或是 图编辑器 应用</p></blockquote><p>最近一直在被G6可视化工具困扰，在逐渐摸索过程中，慢慢可以进行简单图例的搭建<br>以下，根据react中如何使用G6来写这篇文章</p><p>—-Go</p><p>整体项目使用es6模块化开发</p><p>首先下载G6<br>npm install @antv/g6 –save</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import G6 from &apos;@antv/g6&apos;;</span><br><span class="line"></span><br><span class="line">class G6 extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state=&#123;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        // dom 已经渲染完成时加载图片, G6渲染依赖根节点</span><br><span class="line">        this.renderG6();</span><br><span class="line">    &#125;</span><br><span class="line">    renderG6 = () =&gt; &#123;</span><br><span class="line">        // 渲染图所需数据</span><br><span class="line">        const data = &#123;</span><br><span class="line">            nodes: [&#123;</span><br><span class="line">                id: &apos;node1&apos;,</span><br><span class="line">                shape: &apos;customNode&apos;,</span><br><span class="line">                x: 100,</span><br><span class="line">                y: 200</span><br><span class="line">            &#125;,&#123;</span><br><span class="line">                id: &apos;node2&apos;,</span><br><span class="line">                x: 300,</span><br><span class="line">                y: 200</span><br><span class="line">            &#125;],</span><br><span class="line">            edges: [&#123;</span><br><span class="line">                id: &apos;edge1&apos;,</span><br><span class="line">                target: &apos;node2&apos;,</span><br><span class="line">                source: &apos;node1&apos;</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;; </span><br><span class="line">        // 初始化G6图</span><br><span class="line">        const graph = new G6.Graph(&#123;</span><br><span class="line">            container: &apos;mountNode&apos;,</span><br><span class="line">            width: 600,</span><br><span class="line">            height: 300</span><br><span class="line">        &#125;);</span><br><span class="line">        // Graph 是最基础的图类, G6 技术栈中所有关系图都是由该类负责绘制</span><br><span class="line">        // 读数据</span><br><span class="line">        graph.read(data);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div id=&quot;mountNode&quot;&gt;&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../../../../image/g6Demo.png" alt="g6Demo.png"></p><blockquote><p>自定义节点</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    G6.registerNode(&apos;customNode&apos;, &#123;</span><br><span class="line">        draw(item)&#123;</span><br><span class="line">            // draw 是图项最终绘制的接口， 可以拿到shape为customNode的所有数据</span><br><span class="line">            const group = item.getGraphicGroup(); // 获取 G (图形库) 的图形图组</span><br><span class="line">            const model = item.getModel();</span><br><span class="line">            // 图形数据</span><br><span class="line">            return group.addShape(&apos;rect&apos;, &#123;</span><br><span class="line">                attrs: &#123;</span><br><span class="line">                    x: 0,</span><br><span class="line">                    y: 0,</span><br><span class="line">                    width: 100,</span><br><span class="line">                    height: 100,</span><br><span class="line">                    stroke: &apos;red&apos;</span><br><span class="line">                &#125;</span><br><span class="line">                anchor: array || object || callback</span><br><span class="line">                &lt;!-- anchor: [</span><br><span class="line">                    [0.5, 1],     // 底边中点</span><br><span class="line">                    [0.5, 0],     // 上边中点</span><br><span class="line">                    [1, 0],     // 左边中点</span><br><span class="line">                    [1, 0.5],     // 右边中点</span><br><span class="line">                ], --&gt;</span><br><span class="line">                </span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;, &apos;基于某种图形进行绘制的类型&apos;);</span><br></pre></td></tr></table></figure><p><img src="../../../../image/g6DemoAnchor.png" alt="g6DemoAnchor.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;G6&quot;&gt;&lt;a href=&quot;#G6&quot; class=&quot;headerlink&quot; title=&quot;G6&quot;&gt;&lt;/a&gt;G6&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;G6 是一个简单、易用、完备的图可视化引擎，它在高定制能力的基础上，提供了一系列设计优雅、便于使用的图可视化解决方
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>react根据关键字过滤</title>
    <link href="http://yoursite.com/2018/08/02/screen/"/>
    <id>http://yoursite.com/2018/08/02/screen/</id>
    <published>2018-08-02T08:22:19.000Z</published>
    <updated>2018-08-02T08:45:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>需要两个相同的数组</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 输入框变化时，触发onchange事件，进行数据筛选</span><br><span class="line">changeZons = (e) =&gt; &#123;</span><br><span class="line">        const &#123; zonesList &#125; = this.state;</span><br><span class="line">        const searchData = [];</span><br><span class="line">        zonesList.forEach((item) =&gt; &#123;</span><br><span class="line">            let pass = true;</span><br><span class="line">          if (e.target.value) &#123;</span><br><span class="line">            if (item.jobZone.indexOf(e.target.value) &lt; 0) &#123;</span><br><span class="line">              pass = false;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          if (pass) &#123;</span><br><span class="line">            searchData.push(item);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">          zones: searchData,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 下拉菜单变化时，进行数据筛选</span><br><span class="line">    changeZonsAll = (key) =&gt; &#123;</span><br><span class="line">        const &#123; zonesList &#125; = this.state;</span><br><span class="line">        const searchData = [];</span><br><span class="line">        zonesList.forEach((item) =&gt; &#123;</span><br><span class="line">            let pass = true;</span><br><span class="line">          if (key &amp;&amp; key !== &apos;all&apos;) &#123;</span><br><span class="line">            if (item.status.indexOf(key) &lt; 0) &#123;</span><br><span class="line">              pass = false;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          if (pass) &#123;</span><br><span class="line">            searchData.push(item);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">          zones: searchData,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;需要两个相同的数组&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;b
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript异步编程</title>
    <link href="http://yoursite.com/2018/05/24/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/05/24/异步编程/</id>
    <published>2018-05-24T08:52:21.000Z</published>
    <updated>2018-05-28T01:51:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>js是一门单线程语言，异步编程对js语言来说就显得尤为重要</p></blockquote><p>现在实现异步编程的方式基本上有四种</p><ul><li>回调函数</li><li>Promise函数</li><li>Generator函数</li><li>async/await</li></ul><h5 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">比如我们去请求一个接口，当请求完成后执行下一个请求</span><br><span class="line"></span><br><span class="line">this.data(fetch(&apos;xxx&apos;,(res) =&gt; &#123;</span><br><span class="line">    this.dataInfo(fetch(&apos;yyy&apos;), (res) =&gt; &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;))</span><br><span class="line">如果还有更多的请求操作，就会出现多重嵌套。代码很快就会乱成一团，这种情况就是“回调地狱”（callback hell）。</span><br></pre></td></tr></table></figure><h5 id="Promise函数"><a href="#Promise函数" class="headerlink" title="Promise函数"></a>Promise函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">于是，我们提出了Promise函数，它将回调函数的嵌套，改成了链式调用。写法如下：</span><br><span class="line"></span><br><span class="line">let promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  this.data(resolve)</span><br><span class="line">&#125;)</span><br><span class="line">.then(() =&gt; this.dataInfo())</span><br><span class="line">.catch(() =&gt; &#123; console.log(&quot;Error&quot;) &#125;)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Promise的写法只是回调函数的改进，使用then方法，只是让异步任务的两段执行更清楚而已。Promise的最大问题是代码冗余，</span><br><span class="line">请求任务多时，一堆的then，也使得原来的语义变得很不清楚，但是它的状态及其稳定</span><br></pre></td></tr></table></figure><h5 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Generator 函数是一个普通函数，但是有两个特征。</span><br><span class="line">1. function关键字与函数名之间有一个星号；</span><br><span class="line">2. 函数体内部使用yield表达式，定义不同的内部状态</span><br><span class="line"></span><br><span class="line">function* helloWorldGenerator() &#123;</span><br><span class="line">  yield &apos;hello&apos;;</span><br><span class="line">  yield &apos;world&apos;;</span><br><span class="line">  return &apos;ending&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const hw = helloWorldGenerator();</span><br><span class="line">上面代码定义了一个 Generator 函数helloWorldGenerator，它内部有两个yield表达式（hello和world），</span><br><span class="line">即该函数有三个状态：hello，world 和 return 语句（结束执行）。Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。</span><br><span class="line">不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，</span><br><span class="line">必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，</span><br><span class="line">直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。上述代码分步执行如下：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line">// &#123; value: &apos;hello&apos;, done: false &#125;</span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line">// &#123; value: &apos;world&apos;, done: false &#125;</span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line">// &#123; value: &apos;ending&apos;, done: true &#125;</span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line">// &#123; value: undefined, done: true &#125;</span><br><span class="line"></span><br><span class="line">Generator函数的机制更符合我们理解的异步编程思想。</span><br><span class="line"></span><br><span class="line">用户登录的例子，我们用Generator来写，如下：</span><br><span class="line"></span><br><span class="line">let gen = function* () &#123;</span><br><span class="line">  const f1 = yield this.data()</span><br><span class="line">  const f2 = yield this.dataInfo()</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">虽然Generator将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段)</span><br><span class="line">然后出现了 async/await</span><br></pre></td></tr></table></figure><h5 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async function asyncFunc(params) &#123;</span><br><span class="line">  const result1 = await this.login()</span><br><span class="line">  const result2 = await this.getInfo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步函数存在以下四种使用形式：</p><ol><li>函数声明： async function foo() {}</li><li>函数表达式： const foo = async function() {}</li><li>对象的方式： let obj = { async foo() {} }</li><li>箭头函数： const foo = async () =&gt; {}</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对单个异步处理</span><br><span class="line">data = async (xxx) =&gt; &#123;</span><br><span class="line">    const res = await fetch(`xxx`);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对错误的处理：</span><br><span class="line">asyncFunc =  async () =&gt; &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    await otherAsyncFunc();</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    console.error(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">按顺序处理多个异步结果：</span><br><span class="line">asyncFunc = async () =&gt; &#123;</span><br><span class="line">  const result1 = await otherAsyncFunc1();</span><br><span class="line">  console.log(result1);</span><br><span class="line">  const result2 = await otherAsyncFunc2();</span><br><span class="line">  console.log(result2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://es6.ruanyifeng.com/#docs/async" target="_blank" rel="noopener">阮一峰es6</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;js是一门单线程语言，异步编程对js语言来说就显得尤为重要&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在实现异步编程的方式基本上有四种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;回调函数&lt;/li&gt;
&lt;li&gt;Promise函数&lt;/li&gt;
&lt;li&gt;Generator
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>react高阶组件</title>
    <link href="http://yoursite.com/2018/05/23/react%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/05/23/react高阶组件/</id>
    <published>2018-05-23T10:03:35.000Z</published>
    <updated>2018-05-28T01:51:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h2><p>高阶函数的定义：接收函数作为输入，或者输出另一个函数的一类函数，被称作高阶函数。对于高阶组件，它描述的便是接受React组件作为输入，输出一个新的React组件的组件。</p><p>更通俗地描述为，高阶组件通过包裹被传入的React组件，经过一系列处理，最终返回一个相对增强的React组件，供其他组件调用。</p><h3 id="实现一个高阶组件"><a href="#实现一个高阶组件" class="headerlink" title="实现一个高阶组件"></a>实现一个高阶组件</h3><p>来实现一个最简单的高阶组件（函数），它接受一个React组件，包裹后然后返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export default function withHeader(WrappedComponent) &#123;</span><br><span class="line">  return class HOC extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      return &lt;div&gt;</span><br><span class="line">        &lt;div className=&quot;demo-header&quot;&gt;</span><br><span class="line">          我是标题</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;WrappedComponent &#123;...this.props&#125;/&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在其他组件中使用这个高阶组件,两种方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. const EnhanceDemo = withHeader(Demo);</span><br><span class="line">export default class Demo extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        我是一个普通组件</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">在这里使用了ES7里的decorator，来提升写法上的优雅，但是实际上它只是一个语法糖</span><br><span class="line">2. @withHeader</span><br><span class="line">export default class Demo extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        我是一个普通组件</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这个高阶组件被使用了多次，那么在调试的时候，将会看到一大堆HOC，所以这个时候需要做一点小优化，就是在高阶组件包裹后，应当保留其原有名称。<br>这样显示的就是HOC(demo)了<br><img src="../../../../image/hoc.png" alt="hoc.png"></p><p>改写一下上述的高阶组件代码，增加了getDisplayName函数以及静态属性displayName。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function getDisplayName(component) &#123;</span><br><span class="line">  return component.displayName || component.name || &apos;Component&apos;;</span><br><span class="line">&#125;</span><br><span class="line">export default function (WrappedComponent) &#123;</span><br><span class="line">  return class HOC extends Component &#123;</span><br><span class="line">    static displayName = `HOC($&#123;getDisplayName(WrappedComponent)&#125;)`</span><br><span class="line">    render() &#123;</span><br><span class="line">      return &lt;div&gt;</span><br><span class="line">        &lt;div className=&quot;demo-header&quot;&gt;</span><br><span class="line">          我是标题</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;WrappedComponent &#123;...this.props&#125;/&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">displayName是一个用于命名组件的字符串</span><br><span class="line">高阶组件的主要功能是封装并抽离组件的通用逻辑，让此部分逻辑在组件间更好地被复用。</span><br></pre></td></tr></table></figure></p><p>如果需要传入的参数来设置title的值可以将这个组件进行修改就可以的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1. export default function (title) &#123;</span><br><span class="line">  return function (WrappedComponent) &#123;</span><br><span class="line">    return class HOC extends Component &#123;</span><br><span class="line">      render() &#123;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">          &lt;div className=&quot;demo-header&quot;&gt;</span><br><span class="line">            &#123;title</span><br><span class="line">              ? title</span><br><span class="line">              : &apos;我是标题&apos;&#125;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">          &lt;WrappedComponent &#123;...this.props&#125;/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">2.export default(title) =&gt; (WrappedComponent) =&gt; class HOC extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;div className=&quot;demo-header&quot;&gt;</span><br><span class="line">        &#123;title</span><br><span class="line">          ? title</span><br><span class="line">          : &apos;我是标题&apos;&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;WrappedComponent &#123;...this.props&#125;/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="属性代理"><a href="#属性代理" class="headerlink" title="属性代理"></a>属性代理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export default function withHeader(WrappedComponent) &#123;</span><br><span class="line">  return class HOC extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      const newProps = &#123;</span><br><span class="line">        test:&apos;hoc&apos;</span><br><span class="line">      &#125;</span><br><span class="line">      // 透传props，并且传递新的newProps</span><br><span class="line">      return &lt;div&gt;</span><br><span class="line">        &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125;/&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反向继承"><a href="#反向继承" class="headerlink" title="反向继承"></a>反向继承</h3><p>这种方式返回的React组件继承了被传入的组件，所以它能够访问到的区域、权限更多，相比属性代理方式，它更像打入组织内部，对其进行修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export default function (WrappedComponent) &#123;</span><br><span class="line">  return class Inheritance extends WrappedComponent &#123;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      // 可以方便地得到state，做一些更深入的修改。</span><br><span class="line">      console.log(this.state);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      return super.render();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="组合多个高阶组件"><a href="#组合多个高阶组件" class="headerlink" title="组合多个高阶组件"></a>组合多个高阶组件</h3><p>高阶组件为React组件增强了一个功能，如果需要同时增加多个功能需要怎么做？这种场景非常常见，例如我既需要增加一个组件标题，又需要在此组件未加载完成时显示Loading。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@withHeader</span><br><span class="line">@withLoading</span><br><span class="line">class Demo extends Component&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用compose可以简化上述过程，也能体现函数式编程的思想<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const enhance = compose(withHeader,withLoading);</span><br><span class="line">@enhance</span><br><span class="line">class Demo extends Component&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>组合 Compose</p></blockquote><p>compose可以帮助我们组合任意个（包括0个）高阶函数，例如compose(a,b,c)返回一个新的函数d，函数d依然接受一个函数作为入参，只不过在内部会依次调用c,b,a，从表现层对使用者保持透明。<br>基于这个特性，我们便可以非常便捷地为某个组件增强或减弱其特征，只需要去变更compose函数里的参数个数便可。</p><!-- 摘自[知乎](https://zhuanlan.zhihu.com/p/28138664) -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;高阶组件&quot;&gt;&lt;a href=&quot;#高阶组件&quot; class=&quot;headerlink&quot; title=&quot;高阶组件&quot;&gt;&lt;/a&gt;高阶组件&lt;/h2&gt;&lt;p&gt;高阶函数的定义：接收函数作为输入，或者输出另一个函数的一类函数，被称作高阶函数。对于高阶组件，它描述的便是接受React组件
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>dva</title>
    <link href="http://yoursite.com/2018/05/23/dva/"/>
    <id>http://yoursite.com/2018/05/23/dva/</id>
    <published>2018-05-23T01:46:40.000Z</published>
    <updated>2018-05-28T01:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>dva 我认为可以理解为对redux的一种封装</p><blockquote><p>redux 的工作流程图， 更容易去理解dva中的model</p></blockquote><p><img src="../../../../image/redux.jpg" alt="redux.jpg"></p><h2 id="安装dva-cli"><a href="#安装dva-cli" class="headerlink" title="安装dva-cli"></a>安装dva-cli</h2><p>dva 有自己的脚手架，在开发项目的时候，我们需要先安装一个脚手架</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ npm install -g dva-cli</span><br></pre></td></tr></table></figure><p>安装完成后，可以通过 dva -v 查看版本</p><h2 id="创建新应用"><a href="#创建新应用" class="headerlink" title="创建新应用"></a>创建新应用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. dva new myApp </span><br><span class="line">2. cd myApp</span><br><span class="line">3. npm install</span><br><span class="line">4. npm start</span><br></pre></td></tr></table></figure><p>（DVA）定义组件一般有三种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 1. 传统写法</span><br><span class="line">const App = React.createClass(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">// 2. es6 的写法</span><br><span class="line">class App extends React.Component(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">// 3. stateless 的写法（函数的写法，但是不会调用react 的生命周期）</span><br><span class="line">const App = (props) =&gt; (&#123;&#125;);</span><br></pre></td></tr></table></figure></p><p>其中第1种是不推荐的写法，第2种是在你的组件涉及 react 的生命周期方法的时候采用这种写法(可以使用this)，而第3种则是我们一般推荐的写法。</p><h2 id="初始化dva"><a href="#初始化dva" class="headerlink" title="初始化dva"></a>初始化dva</h2><p><img src="../../../../image/dvainstall.png" alt="dvainstall.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">app = dva(opts)</span><br><span class="line"></span><br><span class="line">创建应用，返回 dva 实例</span><br><span class="line"></span><br><span class="line">opts 包含：</span><br><span class="line"></span><br><span class="line">history：指定给路由用的 history，默认是 hashHistory</span><br><span class="line">initialState：指定初始数据，优先级高于 model 中的 state，默认是 &#123;&#125;</span><br><span class="line">如果要配置 history 为 browserHistory，可以这样：</span><br><span class="line"></span><br><span class="line">import createHistory from &apos;history/createBrowserHistory&apos;;</span><br><span class="line">const app = dva(&#123;</span><br><span class="line">  history: createHistory(),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const app = dva(&#123;</span><br><span class="line">  history,</span><br><span class="line">  initialState,</span><br><span class="line">  onError,</span><br><span class="line">  onAction,</span><br><span class="line">  onStateChange,</span><br><span class="line">  onReducer,</span><br><span class="line">  onEffect,</span><br><span class="line">  onHmr,</span><br><span class="line">  extraReducers,</span><br><span class="line">  extraEnhancers,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="定义-Model"><a href="#定义-Model" class="headerlink" title="定义 Model"></a>定义 Model</h2><p>model 是 dva 中最重要的概念</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">app.model(&#123;</span><br><span class="line">  namespace: &apos;todo&apos;, //  model 的命名空间，同时也是他在全局 state 上的属性，只能用字符串，不支持通过 . 的方式创建多层命名空间</span><br><span class="line"></span><br><span class="line">  state: [], // 初始值，优先级低于传给 dva() 的 opts.initialState。</span><br><span class="line">   // const app = dva(&#123;</span><br><span class="line">   //     initialState: &#123; count: 1 &#125;,</span><br><span class="line">   //  &#125;);</span><br><span class="line">   // app.model(&#123;</span><br><span class="line">   //     namespace: &apos;count&apos;,</span><br><span class="line">   //     state: 0,</span><br><span class="line">   // &#125;); </span><br><span class="line">   // state.count 为 1</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">  reducers: &#123; // 以 key/value 格式定义 reducer。用于处理同步操作，唯一可以修改 state 的地方。由 action 触发</span><br><span class="line">    add(state, &#123; payload: todo &#125;) &#123;</span><br><span class="line">      // 保存数据到 state</span><br><span class="line">      return [...state, todo];</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  effects: &#123;</span><br><span class="line">    *save(&#123; payload: todo &#125;, &#123; put, call &#125;) &#123;</span><br><span class="line">      // 调用 saveTodoToServer，成功后触发 `add` action 保存到 state</span><br><span class="line">      yield call(saveTodoToServer, todo);</span><br><span class="line">      yield put(&#123; type: &apos;add&apos;, payload: todo &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  // 以 key/value 格式定义 effect。用于处理异步操作和业务逻辑，不直接修改 state。由 action 触发，可以触发 action，可以和服务器交互，可以获取全局 state 的数据等等。</span><br><span class="line"></span><br><span class="line">// 格式为 *(action, effects) =&gt; void 或 [*(action, effects) =&gt; void, &#123; type &#125;]</span><br><span class="line"></span><br><span class="line">  subscriptions: &#123;</span><br><span class="line">    setup(&#123; history, dispatch &#125;) &#123;</span><br><span class="line">      // 监听 history 变化，当进入 `/` 时触发 `load` action</span><br><span class="line">      return history.listen((&#123; pathname &#125;) =&gt; &#123;</span><br><span class="line">        if (pathname === &apos;/&apos;) &#123;</span><br><span class="line">          dispatch(&#123; type: &apos;load&apos; &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">// 以 key/value 格式定义 subscription。subscription 是订阅，用于订阅一个数据源，然后根据需要 dispatch 相应的 action。在 app.start() 时被执行，数据源可以是当前的时间、服务器的 websocket 连接、keyboard 输入、geolocation 变化、history 路由变化等等。</span><br><span class="line"></span><br><span class="line">// 格式为 (&#123; dispatch, history &#125;, done) =&gt; unlistenFunction。 </span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当我们使用put发送一条action的时候 与之对于的reducers就会接收到这个消息 然后在里面返回state等数据</p><p>在reducers中尽量只做state的数据返回 不要在这里写相关的逻辑</p><p>上面出现了 put call 这两个单词</p><p>其实 不止这几个 </p><p>一般常用的有put call select take </p><ul><li>put  用来发起一条action</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">用于触发action</span><br><span class="line">yield put(&#123; type: &apos;add&apos;, payload: todo &#125;);</span><br></pre></td></tr></table></figure><ul><li>call 以异步的方式调用函数，用于异步逻辑，支持promise</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">yield call(saveTodoToServer, todo);</span><br><span class="line"></span><br><span class="line">saveTodoToServer这里可以是一个请求</span><br><span class="line">export function saveTodoToServer(payload) &#123;</span><br><span class="line">  return axios.get(`xxx`);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>select 从state中获取相关的数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const todo = yield selecct(stete =&gt; state.count)</span><br></pre></td></tr></table></figure><ul><li>take 获取发送的数据</li></ul><blockquote><p>effects   接收数据</p></blockquote><p>dispatch 是根据你effects里面设置的type内容 然后转发到指定的model的 所以你这边 要设置正确以后 在model那边才能接收到你发送的这条action</p><p>dispatch 在使用connect包裹的组件中可以通过 const { dispatch } =  this.props; 拿到</p><p>当我们在页面中进行操作时，可以通过dispatch 分发这条action到model中</p><p>具体的代码，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save = (todo) =&gt;&#123;</span><br><span class="line">    if (todo !== &apos;&apos;) &#123;</span><br><span class="line">        dispath(&#123;type:&apos;count/save&apos;, plyload: todo&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个count就是在model中设置的namespace,save就是effects中你自己起的type<br>plyload是传过去的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">effects: &#123;</span><br><span class="line">    *save(&#123; payload: todo &#125;, &#123; put, call &#125;) &#123;</span><br><span class="line">      // 调用 saveTodoToServer，成功后触发 `add` action 保存到 state</span><br><span class="line">      yield call(saveTodoToServer, todo);</span><br><span class="line">      yield put(&#123; type: &apos;add&apos;, payload: todo &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><blockquote><p>reducers 处理数据</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reducers: &#123; </span><br><span class="line">    add(state, &#123; payload: todo &#125;) &#123;</span><br><span class="line">      // 保存数据到 state</span><br><span class="line">      return [...state, todo];</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><blockquote><p>subscriptions 监听数据</p></blockquote><h1 id="react组件生命周期"><a href="#react组件生命周期" class="headerlink" title="react组件生命周期"></a>react组件生命周期</h1><p>组件的生命周期可分成三个状态：</p><ul><li>Mounting：已插入真实 DOM</li><li>Updating：正在被重新渲染</li><li>Unmounting：已移出真实 DOM<br>生命周期的方法有：</li><li>componentWillMount 在渲染前调用,在客户端也在服务端。</li><li>componentDidMount : 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异部操作阻塞UI)。</li><li>componentWillReceiveProps 在组件接收到一个新的prop时被调用。这个方法在初始化render时不会被调用。</li><li>shouldComponentUpdate 返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。可以在你确认不需要更新组件时使用。</li><li>componentWillUpdate在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。</li><li>componentDidUpdate 在组件完成更新后立即调用。在初始化时不会被调用。</li><li>componentWillUnmount在组件从 DOM 中移除的时候立刻被调用。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;dva 我认为可以理解为对redux的一种封装&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;redux 的工作流程图， 更容易去理解dva中的model&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;../../../../image/redux.jpg&quot; al
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Record</title>
    <link href="http://yoursite.com/2018/05/22/Record/"/>
    <id>http://yoursite.com/2018/05/22/Record/</id>
    <published>2018-05-22T03:33:54.000Z</published>
    <updated>2018-05-28T01:51:03.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当输入框停止的时候进行数据请求</span><br><span class="line">debounce = (cb = () =&gt; &#123; &#125;, time = 500) =&gt; &#123;</span><br><span class="line">    if (this.timer) &#123;</span><br><span class="line">      clearTimeout(this.timer);</span><br><span class="line">    &#125;</span><br><span class="line">    this.timer = setTimeout(() =&gt; &#123;</span><br><span class="line">      cb();</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;;</span><br><span class="line">  handleInputChange = (event) =&gt; &#123;</span><br><span class="line">    const keyword = event.target.value;</span><br><span class="line">    this.debounce(() =&gt; this.getData(keyword, 1));</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>在react-router4.0版本中，取地址栏中的参数时使用以下方式</p></blockquote><ol><li>import qs from ‘querystring’;</li><li>const { id } = qs.parse(this.props.location.search.slice(1));（视情况而定） </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>this is my file</title>
    <link href="http://yoursite.com/2018/05/21/my%20file/"/>
    <id>http://yoursite.com/2018/05/21/my file/</id>
    <published>2018-05-21T11:20:25.000Z</published>
    <updated>2018-05-28T01:50:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="你好-世界"><a href="#你好-世界" class="headerlink" title="你好 世界"></a>你好 世界</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fetch(`xxx`, &#123;</span><br><span class="line">                    method: &apos;POST&apos;,</span><br><span class="line">                    credentials: &apos;same-origin&apos;,</span><br><span class="line">                    headers: &#123;</span><br><span class="line">                        &apos;Content-Type&apos;: &apos;application/json&apos;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    body: JSON.stringify(values),</span><br><span class="line">                    // values 是个对象</span><br><span class="line">                &#125;).then(res =&gt; res.blob().then((blob) =&gt; &#123;</span><br><span class="line">                    const a = document.createElement(&apos;a&apos;);</span><br><span class="line">                    const url = window.URL.createObjectURL(blob);</span><br><span class="line">                    const filename = `$&#123;values.applicationName&#125;.zip`;</span><br><span class="line">                    a.href = url;</span><br><span class="line">                    a.download = filename;</span><br><span class="line">                    a.click();</span><br><span class="line">                    window.URL.revokeObjectURL(url);</span><br><span class="line">                &#125;));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;你好-世界&quot;&gt;&lt;a href=&quot;#你好-世界&quot; class=&quot;headerlink&quot; title=&quot;你好 世界&quot;&gt;&lt;/a&gt;你好 世界&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>欢迎来到我的blog</title>
    <link href="http://yoursite.com/2018/05/21/hello-world/"/>
    <id>http://yoursite.com/2018/05/21/hello-world/</id>
    <published>2018-05-21T10:33:00.000Z</published>
    <updated>2018-05-28T01:50:53.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="此网站用来做一些记录"><a href="#此网站用来做一些记录" class="headerlink" title="此网站用来做一些记录"></a>此网站用来做一些记录</h3><hr><h4 id="or-so"><a href="#or-so" class="headerlink" title="or_so"></a>or_so</h4><p>当我们出了大学的门，挤进了人才市场，从人才市场挤到某张办公桌前，一旦习惯了朝九晚五的工作，就基本停止了思考，放弃了对生命形态的选择，半生只活在一天里。我们懦弱又慵懒地把自己交给所谓安全感，在自认为安全的生活方式中消磨青春，赘肉横生。</p><p>或许生活最好的方式正如海伦.凯勒所说将每一天当做自己的末日，用这样的态度去生活，生命的价值方得以彰显，我们本应纯良知恩、满怀激情地过好每一天，然而一日循着一日，一月接着一月，一年更似一年，这些品质往往被时间冲淡。</p><hr><p><img src="../../../../image/or.jpg" alt="or.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;此网站用来做一些记录&quot;&gt;&lt;a href=&quot;#此网站用来做一些记录&quot; class=&quot;headerlink&quot; title=&quot;此网站用来做一些记录&quot;&gt;&lt;/a&gt;此网站用来做一些记录&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;or-so&quot;&gt;&lt;a href=&quot;#or-so&quot; clas
      
    
    </summary>
    
    
  </entry>
  
</feed>
